#!/usr/bin/env python3

import ipaddress
import subprocess
import io
import re
import random
import argparse
import sys

autogenerated_header = """
# Automatically generated by hxb-net-autoconf, do not edit
"""

class DiscoveryFailed(Exception):
	"""Discovery of networks failed"""

def discover_present_prefixes(iface):
	"""List all prefixes seen by the machine.

	Calls rdisc6 to aquire a list a prefixes and routes announced on the network.

	Args:
		iface: name of the interface to ask for routes

	Returns:
		A tuple (prefixes, routes) of IPv6 networks reachable by this node
	"""
	prefixes = []
	routes = []
	with subprocess.Popen(["rdisc6", iface], stdout=subprocess.PIPE) as proc:
		tio = io.TextIOWrapper(proc.stdout)
		line = tio.readline()
		while len(line) > 0:
			parts = re.match("^ (Prefix|Route)\s*:\s*([^\s]*)", line)
			if parts != None:
				if parts.group(1) == "Prefix":
					prefixes.append(ipaddress.ip_network(parts.group(2)))
				else:
					routes.append(ipaddress.ip_network(parts.group(2)))
			line = tio.readline()
		proc.wait()
		if proc.returncode != 0 and proc.returncode != 2:
			raise DiscoveryFailed
	return (prefixes, routes)

def net_contains(net, cand):
	"""Checks whether a network fully contains another network

	Args:
		net: candidate supernet
		cand: candidate subnet

	Returns:
		True if and only if net is a strict supernet of cand
	"""
	return cand.network_address in net and cand.broadcast_address in net

def exclude_all(netlist):
	"""Calculates a list of private prefixes that are not subnets of given networks

	Args:
		netlist: a list of networks

	Returns:
		A list of networks in fd00::/8 that are not subnets of nets in netlist
	"""
	result = [ ipaddress.ip_network("fd00::/8") ]
	for i in netlist:
		next = []
		for net in result:
			if net_contains(net, i):
				next.extend(net.address_exclude(i))
			elif net_contains(i, net):
				next.extend(i.address_exclude(net))
			else:
				next.extend([net])
		result = next
	return result

def select_networks(prefixes, unusedPrefixes):
	"""Select a suitable pair of prefixes for a HxB router node

	Args:
		prefixes: list of prefixes available for SLAAC
		unusedPrefixes: list if viable prefixes for the HxB network

	Returns:
		A tuple (eth, hxb) of prefixes for the ethernet side and the hexabus side
		of the network. eth may be None if an IPv6 network exists already and SLAAC
		should be used for the ethernet side of things
	"""
	hxb = random.choice(unusedPrefixes)
	while hxb.prefixlen < 63:
		hxb = random.choice(list(hxb.subnets(1)))
	if len(prefixes) > 0:
		return (None, list(hxb.subnets(1))[1])
	else:
		nets = list(hxb.subnets(1))
		return (nets[0], nets[1])

def generate_interfaces_fragment(iftype, prefix, interface, assume_usb = False):
	"""Generates a part of /etc/network/interfaces

	Args:
		prefix: prefix to use for the interface
		interface: interface to configure

	Returns:
		Configuration fragment for /etc/network/interfaces
	"""
	slaac = ("iface {0} inet6 auto\n" +
		"	privext 1\n" +
		"	dhcp 0\n")
	static = ("iface {0} inet6 static\n" +
		"	address {1}\n" +
		"	netmask {2}\n" +
		"	privext 0\n" +
		"	scope site\n")
	result = ""
	if prefix is None:
		result = slaac.format(interface)
	else:
		result = static.format(interface, next(prefix.hosts()), prefix.prefixlen)
	if iftype == "hxb":
		result = "auto {0}\n" + result
		if not assume_usb:
			result += ("	pre-up hxbnm setup wpan0 {0} && ip link set wpan0 up\n" +
				"	post-down (hxbnm save-eeprom wpan0; hxbnm teardown wpan0)\n")
		result = result.format(interface)
	else:
		result += "	post-up (sysctl net.ipv6.conf.{0}.accept_ra=2; rdisc6 {0}) >/dev/null\n".format(interface)
	return autogenerated_header + result

def generate_radvd_fragment(prefix, interface, adv_interval, routes = []):
	"""Generate a radvd.conf fragment to announce a given prefix, possibly with routes

	Args:
		prefix: prefix to announce for SLAAC. If None, SLAAC will be disabled
		routes: routes to announce. Include ::/0 to enable default routes

	Returns:
		A configuration fragment for a radvd.conf
	"""
	include_default = any([ addr.prefixlen == 0 for addr in routes ])
	header = (autogenerated_header + "interface {0} {{\n" +
		"	IgnoreIfMissing on;\n" +
		"	AdvSendAdvert on;\n" +
		"	MaxRtrAdvInterval {1};\n" +
		"	AdvDefaultLifetime {2};\n").format(interface, adv_interval, 3 * adv_interval if include_default else 0)
	prefix_fragment = ""
	if prefix is not None:
		prefix_fragment = ("	prefix {0} {{\n" +
			"		AdvPreferredLifetime {1};\n" +
			"		AdvValidLifetime {2};\n" +
			"	}};\n").format(prefix, adv_interval, 3 * adv_interval)
	footer = "};\n"
	routes_fragment = ""
	for route in routes:
		if route.prefixlen != 0:
			routes_fragment += "	route {0} {{ }};\n".format(route)
	return header + prefix_fragment + routes_fragment + footer

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description = "Autoconfiguration utility for Hexabus routers")
	parser.add_argument("eth", type = str, help = "Ethernet interface name")
	parser.add_argument("hxb", type = str, help = "Hexabus interface name")
	parser.add_argument("have_usb", type = int, help = "0 <=> hexabus interface is not a USB stick")
	parser.add_argument("--iface-conf", metavar = "<file>", type = str, dest = "interfaces",
	                    default = "/etc/network/interfaces",
	                    help = "Write interface config to <file> (default: /etc/network/interfaces)")
	parser.add_argument("--radvd-conf", metavar = "<file>", type = str, dest = "radvd",
	                    default = "/etc/radvd.conf",
	                    help = "Write radvd config to <file> (default: /etc/radvd.conf)")

	try:
		args = parser.parse_args()

		(prefixes, routes) = discover_present_prefixes(args.eth)
		viable = exclude_all(prefixes + routes)
		nets = select_networks(prefixes, viable)

		eth_iface = generate_interfaces_fragment("eth", nets[0], args.eth)
		eth_radvd = generate_radvd_fragment(nets[0], args.eth, 600, [nets[1].supernet(1)])

		hxb_iface = generate_interfaces_fragment("hxb", nets[1], args.hxb, args.have_usb)
		hxb_radvd = generate_radvd_fragment(nets[1], args.hxb, 40, [ipaddress.IPv6Network("::/0")])

		interfaces = open(args.interfaces, "a") if args.interfaces != "-" else sys.stdout
		radvd = open(args.radvd, "a") if args.radvd != "-" else sys.stdout

		interfaces.write(eth_iface)
		interfaces.write(hxb_iface)

		radvd.write(eth_radvd)
		radvd.write(hxb_radvd)
	except DiscoveryFailed:
		exit(1)
	except Exception as e:
		print(e)
		exit(2)
